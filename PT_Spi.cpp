//*******************************************************************************
// SERIAL INTERFACE (from datasheet of ms5541.c)
// The MS5541C communicates with microprocessors and other digital systems via a 
// 3-wire synchronous serial interface as shown in Fig. 1. The SCLK (Serial clock) 
// signal initiates the communication and synchronizes the data transfer with each 
// bit being sampled by the MS5541C on the rising edge of SCLK and each bit being 
// sent by the MS5541C on the rising edge of SCLK. The data should thus be sampled 
// by the microcontroller on the falling edge of SCLK and sent to the MS5541C with 
// the falling edge of SCLK. The SCLK-signal is generated by the microprocessor's 
// system. The digital data provided by the MS5541C on the DOUT pin is either the
// conversion result or the software calibration data. In addition, the signal DOUT 
// (Data out) is also used to indicate the conversion status (conversion-ready 
// signal, see below). The selection of the output data is done by sending the 
// corresponding instruction on the pin DIN (Data input).
//*********************************************************************************



public class PressureSensor
{

	// ------------------------------------------------------------
	// ----------- SETUP SEQUENCES FOR CALIBRATION DATA -----------
	// ------------------------------------------------------------
	//
	// The device does not need a ‘Chip select’ signal. 
	//
	// Instead there is:
	//
	// - a START sequence (3-Bit high) before each SETUP sequence and, 
	// - a STOP sequence (3-Bit low) after each SETUP sequence. 
	//
	// The SETUP sequence consists in SOME-Bit that select: 
	// - a reading of pressure, 
	// - a reading of temperature 
	// - or calibration data.	
	//
	// Read calibration (General): 0x1D
	
	// Read calibration word 1 (W1): 0x50
	// Read calibration word 2 (W2): 0x60
	// Read calibration word 3 (W3): 0x90
	// Read calibration word 4 (W4): 0xA0
	// ------------------------------------------------------------
	
	
	private const uint16 addressCalibrationGeneral_ = 0x1D
	private const uint16 addressCalibrationWord1_ = 0x50
	private const uint16 addressCalibrationWord2_ = 0x60
	private const uint16 addressCalibrationWord3_ = 0x90
	private const uint16 addressCalibrationWord4_ = 0xA0
	
	
	// ------------------------------------------------------------
	// ---------- SETUP SEQUENCES FOR READING MEASUREMENT ---------
	// ------------------------------------------------------------
	//
	// The device does not need a ‘Chip select’ signal. 
	//
	// Instead there is:
	//
	// - a START sequence (3-Bit high) before each SETUP sequence and, 
	// - a STOP sequence (3-Bit low) after each SETUP sequence. 
	//
	// The SETUP sequence consists in SOME-Bit that select: 
	// - a reading of pressure, 
	// - a reading of temperature 
	// - or calibration data.	
	//
	//
	// Conversion start for pressure measurement (D1): 0Fh & 40h
	// Conversion start for temperature measurement (D2): 0Fh & 20h
	// -----------------------------------------------------------------

	private const uint16 addressMeasureGeneral_ = 0x0F
	private const uint16 addressMeasurePressure_ = 0x40
	private const uint16 addressMeasureTemperature_ = 0x20

	// ------------------------------------------------------------
	// ---------- PIN ASSIGNMENT ---------
	// ------------------------------------------------------------
	
	private const uint8 pinMCLK_; // master clock 32.5 kHz
	private const uint8 pinSCLK_; // serial clock
	private const uint8 pinDIN_;  // data in  (out on the maple)
	private const uint8 pinDOUT_; // data out (in  on the maple)
	private const uint8 pinSS_; // slave select
	
	// ------------------------------------------------------------------------
	// Reset sequence command: 15h & 55h & 40h
	// ------------------------------------------------------------------------
	// Reset sequence command: 15h & 55h & 40h


	// -------------------------------------------------------------------
	// ------------------- COEFFICIENTS DECLARATION ----------------------
	// -------------------------------------------------------------------
	// --------------------- FACTORY CALIBRATION -------------------------
	// ------------------ (from datasheet of ms5541.c) -------------------
	// -------------------------------------------------------------------
	// Every module is individually factory calibrated at two temperatures 
	// and two pressures. 
	// 
	// As a result, 6 coefficients necessary to compensate for process 
	// variations and temperature variations are calculated and stored in 
	// the 64-bit PROM of each module. 
	// 
	// These 64-bit (partitioned into four words of 16-bit) must be read 
	// by the microcontroller software and used in the program converting 
	// D1 and D2 into compensated pressure and temperature values.
	// --------------------------------------------------------------------
	// ---------------- PLEASE CHECK IF UINT16 IS CORRECT !!!! 
	// -------------------------------------------------------------------
	// - In MapleLibrary the uint16 is equivalent to an unsigned short, 
	// - equivalent to 16bits
	// -------------------------------------------------------------------

	private uint16 c1; // Pressure Sensitivity - "SENST1"
	private uint16 c2; // Pressure Offset - "OFFT1"
	private uint16 c3; // Temperature Coefficient of Pressure Sensitivity 
			   //                                            - "TCS"
	private uint16 c4; // Temperature Coefficient of Pressure Offset - "TCO"
	private uint16 c5; // Reference Temperature - "Tref"
	private uint16 c6; // Temperature Coefficient of the Temperature 
			   //                                       - "TEMPSENS"

	// ------------------------------------------------------------------
	// -- Limits for coefficients for MS5541-C taken from application 
	// -- notes Intersema AN518.pdf
	// ------------------------------------------------------------------
	//		Min	Typ	Max
	// C1 (13 bit) 	0 	2391 	8191
	// C2 (13 bit) 	0 	4888 	8191
	// C3 (10 bit) 	0 	385 	1023
	// C4 (9 bit) 	0 	221 	511
	// C5 (12 bit) 	0 	1689 	4095
	// C6 (7 bit) 	0 	58 	127	
	

	// ----------------------------------------------------------------------
	// ---------------------- MEASUREMENT DECLARATION -----------------------
	// ----------------------------------------------------------------------
	private float pressure;
	private float temperature;

	// ----------------------------------------------------------------------
	// -------------------------- CONSTRUCTOR -------------------------------
	// ----------------------------------------------------------------------
	public PressureSensor(uint8 pinSpiMOSI, uint8 pinSpiMISO, uint8 pinSpiSCLK, uint8 pinSpiSS, uint8 pinMCLK) : pinDIN_(pinSpiMOSI), pinDOUT_(pinSpiMISO), pinSCLK_(pinSpiSCLK), pinMCLK_(pinMCLK), pinSS_(pinSpiSS)
	{
		//Read calibration data (factory calibrated) from PROM of MS5541C)
		
 		uint16 w1 = this.ReadCalibration(addressCalibrationGeneral_, addressCalibrationWord1_);
  		uint16 w2 = this.ReadCalibration(addressCalibrationGeneral_, addressCalibrationWord2_);
  		uint16 w3 = this.ReadCalibration(addressCalibrationGeneral_, addressCalibrationWord3_);
  		uint16 w4 = this.ReadCalibration(addressCalibrationGeneral_, addressCalibrationWord4_);

		// -- TODO -- CRC Check????

		// Calculate Coefficients c1, c2, c3, c4, c5, c6
		this.CalculateCoefficients(w1, w2, w3, w4);
	}


	// ----------------------------------------------------------------------
	// --- CalculateCoefficients - Reference: datasheet Intersema MS5541C ---
	//
	// Input  : 4 unsigned 16-bit representing the data where calibration
	//          is stored
	//
	// Returns: void
	// ----------------------------------------------------------------------
	private void CalculateCoefficients(uint16 w1, uint16 w2, uint16 w3, uint16 w4)
	{
		// General Note: since these are Unsigned Int, all the binary
		// RIGHT shifts will add 0 at the LEFT side
		this.c1 = w1>>3;   	// Sposta 3 bit indietro (totale 13 bit)

		this.c2 = w1<<10;  	// Sposta 10 bit in avanti i 3 bit più alti (totale 13 bit)
		this.c2 &= 0x1c00; 	// Clean-Mask (AND bit-wise)  0001110000000000
		this.c2 += w2>>6;  	// Sposta w2 6 bit indietro e lo somma a c2

		this.c3 = w3>>6;   	// Sposta 6 bit indietro (totale 10 bit)

		this.c4 = w4>>7;   	// Sposta 7 bit indietro (totale 9 bit)

		this.c5 = w2 & 0x3f; 	// Clean-Mask (AND bit-wise) 00111111
		this.c5 <<= 6;	     	// Sposta 6 bit avanti (totale 12 bit) i bit a destra sono messi a zero
		this.c5 |= (w3 & 0x3f); // Clean-Mask (AND bit-wise) 00111111 pulisce w3 e fa l'OR bit-wise

		this.c6 = w4 & 0x7f;    // Clean-Mask (AND bit-wise) 01111111
	}

	

	// ----------------------------------------------------------------------
	// --- ReadCalibration - Reads 1 word @ addr1/addr2 (16bit address) -----
	//
	// Input  : 2 unsigned 8-bit (to be sent through SPI) representing the 
	//          address where the data are stored
	//
	// Returns: unsigned 16-bit integer, the word where calibration data    
	//          are stored
	// ----------------------------------------------------------------------
	private uint16 ReadCalibration( unit8 addr1, uint8 addr2 )
	{
		// These are Maple-dependent

		//Creates an object to handle spi port n.1
		HardwareSPI spiSensor = new HardwareSPI(1);

		// --------------------------------------------------------------
		// ------ Set the right "Channel-Select" line to 0 --------------
		// --------------------------------------------------------------
		uint8 slaveSelect = 10;
		digitalWrite(slaveSelect, LOW);

		// --------------------------------------------------------------
		// ------ Set SPI configuration register in order to ------------
		// ------ transmit on the rising edge of the clock --------------
		// --------------------------------------------------------------
		// ------ In terms of Polarity and Phase it is: -----------------
		// ------ Pol = 0, Phase = 0 ------------------------------------
		// --------------------------------------------------------------

		spiSensor.begin(SPI_562_500KHZ, MSBFIRST, 0);
	
		
		// ------ Send the 8MSB of the command "Read cal word", 
		// ------ with hex address depending on word no

		spiSensor.send(addr1);

		// ----- Send the 8LSB of the command "Read cal word", 
		// ----- with hex address depending on word no

		spiSensor.send(addr2);

		// --------------------------------------------------------------
		// ------ Set SPI configuration register in order to ------------
		// ------ transmit on the falling edge of the clock -------------
		// --------------------------------------------------------------
		// ------ In terms of Polarity and Phase it is: -----------------
		// ------ Pol = 0, Phase = 1 ------------------------------------
		// --------------------------------------------------------------		
		
		spiSensor.begin(SPI_562_500KHZ, MSBFIRST, 1);

		//Send a dummy byte to read the 8 MSB of the word (whatever)
		uint8 upper = spiSensor.send(addr1);		
		
		//Send a dummy byte to read the 8 LSB of the word (whatever)
		uint8 lower = spiSensor.send(addr2);		
		
		//Set the right CS line to 1
		digitalWrite(slaveSelect, HIGH);

		//The final output is: Word = 8MSB_of_W << 8 & 8LSB_of_W
		unit16 w = ((uint16)upper)<<8 & (uint16)lower;


		return w;
		
		//Note: to optimize code, read the four calibration words in a loop (????)
	}

	
	// -----------------------------------------------------------		
	// ----- ReadMeasurement - Reads Pressure and Temperature 
	// Input  : a 2-length array where to store p,t (by reference)
	// Returns: pt[0] is pressure in mbarA
	//	  : pt[1] is temperature in 0.1°C
	// -----------------------------------------------------------		
	public void ReadMeasurement(float pt[])
	{
		//--------------------------------
		//- MAXIMUM VALUES FOR READ DATA -
		//	min	typ	max      -
		// p 	0 	17000 	40000    -
		// t 	0 	27000 	45000    -
		//--------------------------------
		uint16 p = ReadData(addressMeasureGeneral_, addressMeasurePressure_);
		uint16 t = ReadData(addressMeasureGeneral_, addressMeasureTemperature_);
		
		//---------------------------------------------------------------------
		//-- MAXIMUM VALUES FOR CALCULATION RESULTS	min 	typ 	max
		//-- ut1=8*C5+10000 				10000 	28016 	42760 (Coherent with C5)
		//-- dT=t-ut1 					-11400 	0 	12350 (????? Not coherent)
		//
		// dTmin = (Tmin -Tref)*190TLSB/°C
		// dTmax = (Tmax-Tref)*190TLSB/°C
		//---------------------------------------------------------------------

		//calculate calibration temperature
		int ut1 = 10000 + 8*c5;

		//calculate difference between actual temperature and reference temperature
		int dT = t - ut1;
	
		if(dT != 0)
		{	
			//-- The following term dT2 is the optional 2nd order temperature 
			//-- calculation for a most accurate temperature reading            
			int dT2;
			if (dT<0) dT2 = dT - (dT/128)*(dT/128)/2;
			else dT2 = dT - (dT/128)*(dT/128)/8;

			// -- This is for both 1st order and 2nd order calculation

			//---------------------------------------------------------------------
			//-- MAXIMUM VALUES FOR CALCULATION RESULTS	min	typ	max
			//-- calcTemperature=200+dT*(C6+100)/2^11 	-400 		850
			// with 0.1 °C resolution, in 0.1 °C units)
			//---------------------------------------------------------------------
			calcTemperature = 200 + dT2*(c6+100)/2048;  

			//---------------------------------------------------------------------
			//-- MAXIMUM VALUES FOR CALCULATION RESULTS	min 	typ 	max
			//-- OFF=C2+10000+(C4-250)*dT/2^12 		9246 	14888 	18887
			//
			// OFFmin =C2min +10000+(C4min -250)*dTmax/2^12
			// OFFmax=C2max+10000+(C4max-250)*dTmin /2^12
			//---------------------------------------------------------------------
			int off  = 10000 + c2+(c4-250)*dT/4096;

			//---------------------------------------------------------------------
			//-- MAXIMUM VALUES FOR CALCULATION RESULTS	min 	typ 	max
			//-- SENS=C1/2+(C3+200)*dT/2^13+3000 		1298 	4196 	8939
			//
			// SENSmin =C1min /2+(C3max+200)*dTmin /2^13+3000
			// SENSmax=C1max/2+(C3max+200)*dTmax/2^13+3000
			//---------------------------------------------------------------------
			int sens = 3000 + c1/2+(c3+200)*dT/8192;
			
		}
		else
		{
			int calcTemperature = 200; 
			int off = 10000 + c2;
			int sens = 3000 + c1/2;
		}

		
		//MAXIMUM VALUES FOR CALCULATION RESULTS
		//Pmin = 0 mbar Pmax = 14000 mbar, with 1 mbar resolution
		int actualPressure = sens*(p-off)/4096+1000;
		WHAT IF P-OFF or SENS = 0??

	}

	// -----------------------------------------------------------		
	// ----- Reads measurement D1 or D2 depending on address -----
	// ----- Taken from intersema application note an510.pdf -----
	// -----------------------------------------------------------		
	// The device does not need a ‘Chip select’ signal. 
	//
	// Instead there is: 
	// - a START sequence (3-Bit high) before each SETUP sequence and 
	// - a STOP sequence (3-Bit low) after each SETUP sequence. 
	//
	// The SETUP sequence consists in 4-Bit that select a reading 
	// of pressure, temperature or calibration data. 
	//
	// In case of pressure- (D1) or temperature- (D2) reading the 
	// module acknowledges the start of a conversion by a low to 
	// high transition at pin DOUT.
	//
	// Two additional clocks at SCLK are required after the 
	// acknowledge signal. Then SCLK is to be held low by the
	// microcontroller until a high to low transition on DOUT 
	// indicates the end of the conversion.
	// -----------------------------------------------------------		
	private uint16 ReadData(uint8 address1, uint8 address2)
	{
		// These are Maple-dependent

		//Creates an object to handle spi port n.1
		HardwareSPI spiSensor = new HardwareSPI(1);

		// --------------------------------------------------------------
		// ------ Set the right "Channel-Select" line to 0 --------------
		// --------------------------------------------------------------
		uint8 slaveSelect = 10;
		digitalWrite(slaveSelect, LOW);

		// --------------------------------------------------------------
		// ------ Set SPI configuration register in order to ------------
		// ------ transmit on the rising edge of the clock --------------
		// --------------------------------------------------------------
		// ------ In terms of Polarity and Phase it is: -----------------
		// ------ Pol = 0, Phase = 0 ------------------------------------
		// --------------------------------------------------------------

		spiSensor.begin(SPI_562_500KHZ, MSBFIRST, 0);

		
		//Send a dummy byte to read the 8 MSB of the word (whatever)
		uint8 upper = spiSensor.send(address1);		
		
		//Send a dummy byte to read the 8 LSB of the word (whatever)
		uint8 lower = spiSensor.send(address2);		

		// --------------------------------------------------------------
		// ------ Set SPI configuration register in order to ------------
		// ------ transmit on the falling edge of the clock -------------
		// --------------------------------------------------------------
		// ------ In terms of Polarity and Phase it is: -----------------
		// ------ Pol = 0, Phase = 0 ------------------------------------
		// --------------------------------------------------------------		
		
		spiSensor.begin(SPI_562_500KHZ, MSBFIRST, 1);		
		
		//Wait 35ms (conversion time)
		?????????????????????????????????????????????????????????????????
		
		
		//Send a dummy byte to read the 8 MSB of the word (whatever)
		uint8 upper = spiSensor.send(address1);		
		
		//Send a dummy byte to read the 8 LSB of the word (whatever)
		uint8 lower = spiSensor.send(address2);		
		
		//Set the right CS line to 1
		digitalWrite(slaveSelect, HIGH);
		
		//The final output is: Word = 8MSB_of_W << 8 & 8LSB_of_W
		unit16 w = ((uint16)upper)<<8 & (uint16)lower;

		return w;
	}
	


	//Honestly I still don't know what is the meaning of this reset sequence
	ResetSensor()
	{
		//Reset sequence command
		
		//Set the right CS line to 0
		
		//Set SPI configuration register in order to transmit on the rising edge of the clock
		
		//Send the 8MSB of the command - Rst seq: 15h
		
		//Send the middle byte of the command - Rst seq: 55h
		
		//Send the 8LSB of the command - Rst seq : 40h
		
		//Set the right CS line to 1
	}
}
